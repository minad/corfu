#+title: corfu.el - Completion Overlay Region FUnction
#+author: Daniel Mendler
#+language: en
#+export_file_name: corfu.texi
#+texinfo_dir_category: Emacs
#+texinfo_dir_title: Corfu: (corfu).
#+texinfo_dir_desc: Completion Overlay Region FUnction

#+html: <a href="https://www.gnu.org/software/emacs/"><img alt="GNU Emacs" src="https://github.com/minad/corfu/blob/screenshots/emacs.svg?raw=true"/></a>
#+html: <a href="http://elpa.gnu.org/packages/corfu.html"><img alt="GNU ELPA" src="https://elpa.gnu.org/packages/corfu.svg"/></a>
#+html: <a href="http://elpa.gnu.org/devel/corfu.html"><img alt="GNU-devel ELPA" src="https://elpa.gnu.org/devel/corfu.svg"/></a>

* Introduction

  Corfu enhances completion at point with a small completion popup. The current
  candidates are shown in a popup below or above the point. Corfu is the
  minimalistic ~completion-in-region~ counterpart of the [[https://github.com/minad/vertico][Vertico]] minibuffer UI.

  Corfu is a small package, which relies on the Emacs completion facilities and
  concentrates on providing a polished completion UI. Completions are either
  provided by commands like ~dabbrev-completion~ or by pluggable backends
  (~completion-at-point-functions~, Capfs). Most programming language major modes
  implement a Capf. Furthermore the language server packages, [[https://github.com/joaotavora/eglot][Eglot]] and
  [[https://github.com/emacs-lsp/lsp-mode][Lsp-mode]], use Capfs which talk to the LSP server to retrieve the completions.
  Corfu does not include its own completion backends. The Emacs built-in Capfs
  and the Capfs provided by other programming language packages are usually
  sufficient. A few additional Capfs and completion utilities are provided by
  the [[https://github.com/minad/cape][Cape]] package.

  *NOTE*: Corfu uses child frames to show the popup. For now Corfu falls back to
  the default setting of the ~completion-in-region-function~ on non-graphical
  displays.

  [[https://github.com/minad/corfu/blob/screenshots/light.png?raw=true]]

  [[https://github.com/minad/corfu/blob/screenshots/dark.png?raw=true]]

* Features

  - Timer-based auto-completions (/off/ by default, set ~corfu-auto~).
  - Popup display with scrollbar indicator and arrow key navigation.
  - The popup can be summoned explicitly by pressing =TAB= at any time.
  - The current candidate is inserted with =TAB= and selected with =RET=.
  - Candidates sorting by prefix, string length and alphabetically.
  - The selected candidate is previewed (configurable via ~corfu-preview-current~).
  - The selected candidate automatically committed on further input by default.
    (configurable via ~corfu-preview-current~).
  - The [[https://github.com/oantolin/orderless][Orderless]] completion style is supported. The filter string can contain
    arbitrary characters, after inserting a space via =M-SPC= (configurable via
    ~corfu-quit-at-boundary~ and ~corfu-separator~).
  - Deferred completion style highlighting for performance.
  - Jumping to location/documentation of current candidate.
  - Support for candidate annotations and documentation in the echo area.
  - Deprecated candidates are crossed out in the display.
  - Icons can be provided by an external package via margin formatter functions.

* Installation and Configuration

  Corfu is available from [[http://elpa.gnu.org/packages/corfu.html][GNU ELPA]], such that it can be installed directly via
  ~package-install~. After installation, the global minor mode can be enabled with
  =M-x corfu-global-mode=. In order to configure Corfu and other packages in your
  init.el, you may want to use ~use-package~.

  Corfu is highly flexible and customizable via ~corfu-*~ customization variables,
  such that you can adapt it precisely to your requirements. However in order to
  quickly try out the Corfu completion package, it should be sufficient to
  activate ~corfu-global-mode~. Then you experiment with manual completion for
  example in an Elisp buffer or in an Eshell or Shell buffer. For auto
  completion, set ~corfu-auto=t~ before turning on ~corfu-global-mode~.

  If you start to configure the package more deeply, I recommend to give the
  Orderless completion style a try for filtering. Orderless completion is
  different from the familiar prefix TAB completion. Corfu can be used with the
  default completion styles. The use of Orderless is not a necessity. See also
  the [[https://github.com/minad/corfu/wiki][Corfu Wiki]] for additional configuration tips. In particular the Lsp-mode
  configuration is documented in the Wiki.

  Here is an example configuration:

  #+begin_src emacs-lisp
    (use-package corfu
      ;; Optional customizations
      ;; :custom
      ;; (corfu-cycle t)                ;; Enable cycling for `corfu-next/previous'
      ;; (corfu-auto t)                 ;; Enable auto completion
      ;; (corfu-separator ?\s)          ;; Orderless field separator
      ;; (corfu-quit-at-boundary nil)   ;; Never quit at completion boundary
      ;; (corfu-quit-no-match nil)      ;; Never quit, even if there is no match
      ;; (corfu-preview-current nil)    ;; Disable current candidate preview
      ;; (corfu-preselect-first nil)    ;; Disable candidate preselection
      ;; (corfu-on-exact-match nil)     ;; Configure handling of exact matches
      ;; (corfu-echo-documentation nil) ;; Disable documentation in the echo area
      ;; (corfu-scroll-margin 5)        ;; Use scroll margin

      ;; You may want to enable Corfu only for certain modes.
      ;; :hook ((prog-mode . corfu-mode)
      ;;        (shell-mode . corfu-mode)
      ;;        (eshell-mode . corfu-mode))

      ;; Recommended: Enable Corfu globally.
      ;; This is recommended since dabbrev can be used globally (M-/).
      :init
      (corfu-global-mode))

    ;; Optionally use the `orderless' completion style. See `+orderless-dispatch'
    ;; in the Consult wiki for an advanced Orderless style dispatcher.
    ;; Enable `partial-completion' for files to allow path expansion.
    ;; You may prefer to use `initials' instead of `partial-completion'.
    (use-package orderless
      :init
      ;; Configure a custom style dispatcher (see the Consult wiki)
      ;; (setq orderless-style-dispatchers '(+orderless-dispatch)
      ;;       orderless-component-separator #'orderless-escapable-split-on-space)
      (setq completion-styles '(orderless)
            completion-category-defaults nil
            completion-category-overrides '((file (styles . (partial-completion))))))

    ;; Use dabbrev with Corfu!
    (use-package dabbrev
      ;; Swap M-/ and C-M-/
      :bind (("M-/" . dabbrev-completion)
             ("C-M-/" . dabbrev-expand)))

    ;; A few more useful configurations...
    (use-package emacs
      :init
      ;; TAB cycle if there are only few candidates
      (setq completion-cycle-threshold 3)

      ;; Emacs 28: Hide commands in M-x which do not apply to the current mode.
      ;; Corfu commands are hidden, since they are not supposed to be used via M-x.
      ;; (setq read-extended-command-predicate
      ;;       #'command-completion-default-include-p)

      ;; Enable indentation+completion using the TAB key.
      ;; `completion-at-point' is often bound to M-TAB.
      (setq tab-always-indent 'complete))
  #+end_src

  See also the [[https://github.com/minad/corfu/wiki][Corfu Wiki]] for additional configuration tips. For more general
  documentation read the chapter about completion in the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Completion.html][Emacs manual]]. If you
  want to create your own Capfs, you can find documentation about completion in
  the [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Completion.html][Elisp manual]].

** Auto completion

  Auto completion is disabled by default, but can be enabled by setting
  ~corfu-auto=t~. Furthermore you may want to configure Corfu to quit completion
  eagerly, such that the completion popup stays out of your way when it
  appeared unexpectedly.

  #+begin_src emacs-lisp
    ;; Enable auto completion and configure quitting
    (setq corfu-auto t
          corfu-quit-no-match 'separator) ;; or t
  #+end_src

  In general, I recommend to experiment a bit with the various settings and key
  bindings to find a configuration which works for you. There is no one size
  fits all solution. Some people like auto completion, some like manual
  completion, some want to cycle with TAB and some with the arrow keys...

** Completing with Corfu in the minibuffer

Corfu can be used for completion in the minibuffer, since it relies on child
frames to display the candidates. By default, ~corfu-global-mode~ does not
activate ~corfu-mode~ in the minibuffer, to avoid interference with specialised
minibuffer completion UIs like Vertico or Mct. However you may still want to
enable Corfu completion for commands like ~M-:~ (~eval-expression~) or ~M-!~
(~shell-command~), which read from the minibuffer. Activate ~corfu-mode~ only if
~completion-at-point~ is bound in the minibuffer-local keymap to achieve this
effect.

#+begin_src emacs-lisp
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      ;; (setq-local corfu-auto nil) Enable/disable auto completion
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)
#+end_src

You can also enable Corfu more generally for every minibuffer, as long as no
other completion UI is active. If you use Mct or Vertico as your main minibuffer
completion UI, the following snippet should yield the desired result.

#+begin_src emacs-lisp
  (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active)
                (bound-and-true-p vertico--input))
      ;; (setq-local corfu-auto nil) Enable/disable auto completion
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)
#+end_src

** Completing with Corfu in the Eshell or Shell

When completing in the Eshell I recommend conservative local settings without
auto completion, such that the completion behavior is similar to widely used
shells like Bash, Zsh or Fish.

#+begin_src emacs-lisp
  (add-hook 'eshell-mode-hook
            (lambda ()
              (setq-local corfu-auto nil)
              (corfu-mode)))
#+end_src

When pressing =RET= while the Corfu popup is visible, the ~corfu-insert~ command
will be invoked. This command does inserts the currently selected candidate, but
it does not send the prompt input to Eshell or the comint process. Therefore you
often have to press =RET= twice which feels like an unnecessary double
confirmation. Fortunately it is easy to improve this! In my configuration I
define the command ~corfu-insert-and-send~ which performs the two steps at once.

#+begin_src emacs-lisp
  (defun corfu-insert-and-send ()
    (interactive)
    ;; 1. First insert the completed candidate
    (corfu-insert)
    ;; 2. Send the entire prompt input to the shell
    (cond
     ((and (derived-mode-p 'eshell-mode) (fboundp 'eshell-send-input))
      (eshell-send-input))
     ((derived-mode-p 'comint-mode)
      (comint-send-input))))

  (define-key corfu-map "\r" #'+corfu-insert-and-send)
#+end_src

Shell completion uses the flexible ~pcomplete~ mechanism internally, which allows
you to program the completions per shell command. If you want to know more, look
into this [[https://www.masteringemacs.org/article/pcomplete-context-sensitive-completion-emacs][blog post]], which shows how to configure pcomplete for git commands. I
recommend the [[https://github.com/JonWaltman/pcmpl-args.el][pcmpl-args]] package which extends Pcomplete with completion support
and helpful annotation support for more commands. Similar to the Fish shell,
pcmpl-args uses man page parsing and --help output parsing to dynamically
generate completions. This package brings Eshell completion to another level!

Unfortunately Pcomplete has a few technical issues, which we can work around
with the [[https://github.com/minad/cape][Cape]] library (Completion at point extensions). Cape provides wrappers,
which sanitize the pcomplete function. Ideally the bugs in pcomplete should be
fixed upstream. *For now these two advices are strongly recommended to achieve a
sane Eshell experience.*

#+begin_src emacs-lisp
  ;; Silence the pcomplete capf, no errors or messages!
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)

  ;; Ensure that pcomplete does not write to the buffer
  ;; and behaves as a pure `completion-at-point-function'.
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify)
#+end_src

** Orderless completion

[[https://github.com/oantolin/orderless][Orderless]] is an advanced completion style that supports multi-component search
filters separated by a configurable character (space, by default). Normally,
entering characters like space which lie outside the completion region
boundaries (words, typically) causes Corfu to quit. This behavior is helpful
with auto-completion, which may pop-up when not desired, e.g. on entering a new
variable name. Just keep typing and Corfu will get out of the way.

But orderless search terms can contain arbitrary characters; they are also
interpreted as regular expressions. To use orderless, set ~corfu-separator~ (a
space, by default) to the primary character of your orderless component
separator.

Then, when a new orderless component is desired, use =M-SPC=
(~corfu-insert-separator~) to enter the /first/ component separator in the input,
and arbitrary orderless search terms and new separators can be entered
thereafter.

To treat the entire input as Orderless input, you can set the customization
option ~corfu-quit-at-boundary=t~. This disables the predicate which checks if the
current completion boundary has been left. In contrast, if you /always/ want to
quit at the boundary, simply set ~corfu-quit-at-boundary=nil~. By default
~corfu-quit-at-boundary~ is set to ~separator~ which quits at completion boundaries
as long as no separator has been inserted with ~corfu-insert-separator~.

Finally, there exists the user option ~corfu-quit-no-match~ which is set to
=separator= by default. With this setting Corfu stays alive as soon as you start
advanced filtering with a ~corfu-separator~ even if there are no matches, for
example due to a typo. As long as no separator character has been inserted with
~corfu-insert-separator~, Corfu will still quit if there are no matches. This
ensures that the Corfu popup goes away quickly if completion is not possible.

In the following we show two configurations, one which works best with auto
completion and one which may work better with manual completion if you prefer to
always use =SPC= to separate the Orderless components.

 #+begin_src emacs-lisp
   ;; Auto completion example
   (use-package corfu
     :custom
     (corfu-auto t)          ;; Enable auto completion
     ;; (corfu-separator ?_) ;; Set to orderless separator, if not using space
     :bind
     ;; Another key binding can be used, such as S-SPC.
     ;; (:map corfu-map ("M-SPC" . corfu-insert-separator))
     :init
     (corfu-global-mode))

   ;; Manual completion example
   (use-package corfu
     :custom
     ;; (corfu-separator ?_) ;; Set to orderless separator, if not using space
     :bind
     ;; Configure SPC for separator insertion
     (:map corfu-map ("SPC" . corfu-insert-separator))
     :init
     (corfu-global-mode))
#+end_src

** TAB-and-Go completion

You may be interested in configuring Corfu in TAB-and-Go style. Pressing TAB
moves to the next candidate and further input will then commit the selection.

#+begin_src emacs-lisp
  (use-package corfu
    ;; TAB-and-Go customizations
    :custom
    (corfu-cycle t)             ;; Enable cycling for `corfu-next/previous'
    (corfu-preselect-first nil) ;; Disable candidate preselection

    ;; Use TAB for cycling, default is `corfu-complete'.
    :bind
    (:map corfu-map
          ("TAB" . corfu-next)
          ([tab] . corfu-next)
          ("S-TAB" . corfu-previous)
          ([backtab] . corfu-previous))

    :init
    (corfu-global-mode))
#+end_src

** Transfer completion to the minibuffer

Sometimes it is useful to transfer the Corfu completion session to the
minibuffer, since the minibuffer offers richer interaction features. In
particular, [[https://github.com/oantolin/embark][Embark]] is available in the minibuffer, such that you can act on the
candidates or export/collect the candidates to a separate buffer. Hopefully we
can also add Corfu-support to Embark in the future, such that at least
export/collect is possible directly from Corfu. But in my opinion having the
ability to transfer the Corfu completion to the minibuffer is an even better
feature, since further completion can be performed there.

The command ~corfu-move-to-minibuffer~ is defined here in terms of
~consult-completion-in-region~, which uses the minibuffer completion UI via
~completing-read~.

#+begin_src emacs-lisp
  (defun corfu-move-to-minibuffer ()
    (interactive)
    (let ((completion-extra-properties corfu--extra)
          completion-cycle-threshold completion-cycling)
      (apply #'consult-completion-in-region completion-in-region--data)))
  (define-key corfu-map "\M-m" #'corfu-move-to-minibuffer)
#+end_src

* Key bindings

  Corfu uses a transient keymap ~corfu-map~ which is active while the popup is shown.
  The keymap defines the following remappings and bindings:

  - ~beginning-of-buffer~ -> ~corfu-first~
  - ~end-of-buffer~ -> ~corfu-last~
  - ~scroll-down-command~ -> ~corfu-scroll-down~
  - ~scroll-up-command~ -> ~corfu-scroll-up~
  - ~next-line~, =down=, =M-n= -> ~corfu-next~
  - ~previous-line~, =up=, =M-p= -> ~corfu-previous~
  - ~completion-at-point~, =TAB= -> ~corfu-complete~
  - =RET= -> ~corfu-insert~
  - =M-g= -> ~corfu-show-location~
  - =M-h= -> ~corfu-show-documentation~
  - =M-SPC= -> ~corfu-insert-separator~
  - =C-g= -> ~corfu-quit~
  - ~keyboard-escape-quit~ -> ~corfu-reset~

* Complementary packages

  Corfu works well together with all packages providing code completion via the
  ~completion-at-point-functions~. Many modes and packages already provide a Capf
  out of the box. Nevertheless you may want to look into complementary packages
  to enhance your setup.

  - [[https://github.com/oantolin/orderless][Orderless]]: Corfu supports completion styles, including the advanced
    [[https://github.com/oantolin/orderless][Orderless]] completion style, where the filtering expressions are separated by
    spaces or another character (see ~corfu-separator~).

  - [[https://github.com/minad/cape][Cape]]: I collect additional Capf backends and =completion-in-region= commands
    in my [[https://github.com/minad/cape][Cape]] package. The package provides a file path, a dabbrev completion
    backend and a backend which allows you to enter unicode characters in the
    form of TeX commands. Cape provides an adapter to reuse Company backends in
    Corfu. Furthermore the function ~cape-super-capf~ can merge/groups multiple
    Capfs, such that the candidates of multiple Capfs are displayed together at
    the same time.

  - [[https://github.com/jdtsmith/kind-icon][kind-icon]]: Icons are supported by Corfu via an external package. For example
    the [[https://github.com/jdtsmith/kind-icon][kind-icon]] package provides beautifully styled SVG icons based on
    monochromatic icon sets like material design.

  - [[https://github.com/galeo/corfu-doc][corfu-doc]]: The corfu-doc package displays the candidate documentation in a
    popup next to the Corfu popup, similar to =company-quickhelp=.

  - [[https://github.com/JonWaltman/pcmpl-args.el][pcmpl-args]]: Extend the Eshell/Shell Pcomplete mechanism with support for many
    more commands. Similar to the Fish shell, Pcomplete uses man page parsing to
    dynamically retrieve the completions and helpful annotations. This package
    brings Eshell completions to another level!

  - [[https://github.com/minad/tempel][Tempel]]: Tiny template/snippet package with templates in Lisp syntax, which
    can be used in conjunction with Corfu.

  - [[https://github.com/minad/vertico][Vertico]]: You may also want to look into my [[https://github.com/minad/vertico][Vertico]] package. Vertico is the
    minibuffer completion counterpart of Corfu.

* Alternatives

  - [[https://github.com/company-mode/company-mode][Company]]: Company is a widely used and mature completion package, which
    implements a similar interaction model and popup UI as Corfu. While Corfu
    relies exclusively on the standard Emacs completion API (Capfs), Company
    defines its own API for the backends. Furthermore Company includes its
    completion backends, which are incompatible with the Emacs completion
    infrastructure. As a result of this design, Company is a more complex
    package than Corfu. Company by default uses overlays to display the popup in
    contrast to the child frames used by Corfu. Overall both packages work well.
    Company is more mature but the integration into Emacs is a bit less tight,
    since for example the ~completion-at-point~ command (or the
    ~completion-in-region~ function) does not invoke Company.

  - [[https://gitlab.com/protesilaos/mct][Mct]]: Protesilaos' Minibuffer Confines Transcended package supports both
    minibuffer completion and completion in region. It reuses the default
    completion UI for this purpose and installs a timer which live updates the
    completion buffer. The main advantage of Mct is that you work with a regular
    Emacs buffer instead of with a popup. You can take advantage of the usual
    Emacs commands to navigate in the completions buffer. On top, Mct enhances
    the movement such that you can quickly switch between the completions buffer
    and the minibuffer or the region which is being completed. Mct does not
    support timer-based auto completion, but the integration into Emacs is
    naturally tight.

  - [[https://github.com/minad/consult][consult-completion-in-region]]: The Consult package provides the function
    ~consult-completion-in-region~ which can be set as
    ~completion-in-region-function~ such that it handles ~completion-at-point~. The
    function works by transferring the in-buffer completion to the minibuffer.
    In the minibuffer, the minibuffer completion UI, for example [[https://github.com/minad/vertico][Vertico]] takes
    over. If you prefer to perform all your completions in the minibuffer
    ~consult-completion-in-region~ is your best option.

* Caveats

  Corfu is robust in most scenarios. There are a few known technical caveats.

  - Corfu uses child frames to show the popup. For now Corfu falls back to the
    default setting of the ~completion-in-region-function~ on non-graphical
    displays. You can use one of the alternatives in terminals.

  - Corfu does not sort by history, since ~completion-at-point~ does not
    maintain a history (See branch =history= for a possible solution).

* Contributions

  Since this package is part of [[http://elpa.gnu.org/packages/corfu.html][GNU ELPA]] contributions require a copyright
  assignment to the FSF.
